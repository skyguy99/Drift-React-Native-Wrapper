'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _jestPluginSet = require('jest-plugin-set');

var _jestPluginSet2 = _interopRequireDefault(_jestPluginSet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TOOD(mark): We should try to create a local scope to not clutter
// global. This works for now.
// Libraries
var scope = global;

/**
 * Method can either be a single string `getTask` or it can be a chain
 * of methods `props.app.cdn`. We evaluate all parts of the split method
 * making sure to chain the caller as we traverse the methods.
 */
var evaluateMethod = function evaluateMethod(subject, method) {
  var tokens = method.split('.');
  var caller = subject;
  var value = subject;

  tokens.forEach(function (token) {
    caller = value;

    // By default, we just treat it as a property.
    //
    // Example:
    //     its('id', () => {});
    //
    // This tests `subject.id`.
    //
    value = value[token];

    (0, _invariant2.default)(value !== undefined, 'Undefined method: \'' + token + '\' for subject: ' + caller + '.');

    // If it's a function (like a getter function) and it takes in 0 args,
    // then we can also evaluate it:
    //
    // Example:
    //     its('getIsCurrent', () => {});
    //
    // This tests `subject.getIsCurrent()`.
    //
    if (typeof value === 'function') {
      value = value.call(caller);
    }
  });

  return value;
};

var its = function its(method, expectation) {
  describe('#' + method, function () {
    (0, _jestPluginSet2.default)('__itsSubject', function () {
      var subject = scope.__subject;

      (0, _invariant2.default)(subject !== undefined, 'Subject is not defined. Make sure you set a subject using: ' + '\'subject(() => someVariable);\'');

      return evaluateMethod(subject, method);
    });

    (0, _jestPluginSet2.default)('isExpected', function () {
      return expect(scope.__itsSubject);
    });

    // TODO(mark): Better it messages, right now we only get a good message
    // when it fails.
    it('is correct', function () {
      // Call the expectation to assert values.

      // TODO(mark): expect.assertions(number) is coming soon to jest.
      // Until then, we'll have to keep hackily checking that the return
      // value is undefined.
      var result = expectation.call(scope);

      // All calls to `isExpected` will set the `actual` value.
      // This is a quick check to make sure `isExpected` was called.
      (0, _invariant2.default)(typeof result === 'undefined', 'Expectation did not call \'isExpected\'. Test did not validate ' + 'anything.');
    });
  });
};

exports.default = its;